// qcustom3dvolume.sip generated by MetaSIP
//
// This file is part of the QtDataVisualization Python extension module.
//
// Copyright (c) 2020 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQtDataVisualization.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%If (QtDataVisualization_1_2_0 -)
// Mapped types needed by QCustom3DVolume
%MappedType QVector<QImage *>
        /TypeHintIn="Iterable[QImage]", TypeHintOut="List[QImage]",
        TypeHintValue="[]"/
{
%TypeHeaderCode
#include <qimage.h>
#include <qvector.h>
%End

%ConvertFromTypeCode
    PyObject *l = PyList_New(sipCpp->size());

    if (!l)
        return 0;

    for (int i = 0; i < sipCpp->size(); ++i)
    {
        QImage *t = sipCpp->at(i);

        PyObject *tobj = sipConvertFromType(t, sipType_QImage, sipTransferObj);

        if (!tobj)
        {
            Py_DECREF(l);

            return 0;
        }

        PyList_SetItem(l, i, tobj);
    }

    return l;
%End

%ConvertToTypeCode
    PyObject *iter = PyObject_GetIter(sipPy);

    if (!sipIsErr)
    {
        Py_XDECREF(iter);

        return (iter
#if PY_MAJOR_VERSION < 3
                && !PyString_Check(sipPy)
#endif
                && !PyUnicode_Check(sipPy));
    }

    if (!iter)
    {
        *sipIsErr = 1;

        return 0;
    }

    QVector<QImage *> *ql = new QVector<QImage *>;
 
    for (SIP_SSIZE_T i = 0; ; ++i)
    {
        PyErr_Clear();
        PyObject *itm = PyIter_Next(iter);

        if (!itm)
        {
            if (PyErr_Occurred())
            {
                delete ql;
                Py_DECREF(iter);
                *sipIsErr = 1;

                return 0;
            }

            break;
        }

        QImage *t = reinterpret_cast<QImage *>(
                sipForceConvertToType(itm, sipType_QImage, sipTransferObj, 0,
                        0, sipIsErr));
 
        if (*sipIsErr)
        {
            PyErr_Format(PyExc_TypeError,
                    "index " SIP_SSIZE_T_FORMAT " has type '%s' but 'QImage' is expected",
                    i, sipPyTypeName(Py_TYPE(itm)));

            Py_DECREF(itm);
            delete ql;
            Py_DECREF(iter);

            return 0;
        }

        ql->append(t);

        Py_DECREF(itm);
    }

    Py_DECREF(iter);
 
    *sipCppPtr = ql;
 
    return sipGetState(sipTransferObj);
%End
};


%MappedType QVector<unsigned char> /TypeHint="sip.array"/
{
%TypeHeaderCode
#include <qvector.h>
%End

%ConvertFromTypeCode
    return sipConvertToArray(reinterpret_cast<void *>(sipCpp->data()), "B", sipCpp->size(), 0);
%End

%ConvertToTypeCode
    if (!sipIsErr)
#if PY_VERSION_HEX >= 0x03000000
        return sipGetBufferInfo(sipPy, NULL);
#elif PY_VERSION_HEX >= 0x02060300
        return (PyObject_CheckBuffer(sipPy) || PyObject_CheckReadBuffer(sipPy));
#else
        return PyObject_CheckReadBuffer(sipPy);
#endif

    const void *buffer;
    SIP_SSIZE_T buffer_len;

#if PY_VERSION_HEX >= 0x03000000
    sipBufferInfoDef bi;

    if (sipGetBufferInfo(sipPy, &bi) < 0)
    {
        *sipIsErr = 1;
        return 0;
    }

    if (bi.bi_format != NULL && *bi.bi_format != 'B')
    {
        PyErr_SetString(PyExc_TypeError,
                "a buffer of unsigned bytes is required");
        *sipIsErr = 1;
        return 0;
    }

    buffer = bi.bi_buf;
    buffer_len = bi.bi_len;
#else
    if (PyObject_AsReadBuffer(sipPy, &buffer, &buffer_len) < 0)
    {
        *sipIsErr = 1;
        return 0;
    }
#endif

    QVector<unsigned char> *qv = new QVector<unsigned char>(buffer_len);

    for (SIP_SSIZE_T i = 0; i < buffer_len; ++i)
        (*qv)[i] = reinterpret_cast<const uchar *>(buffer)[i];

    *sipCppPtr = qv;
 
#if PY_VERSION_HEX >= 0x03000000
    sipReleaseBufferInfo(&bi);
#endif

    return sipGetState(sipTransferObj);
%End
};
%End
%If (QtDataVisualization_1_2_0 -)

namespace QtDataVisualization
{
%TypeHeaderCode
#include <qcustom3dvolume.h>
%End

    class QCustom3DVolume : QtDataVisualization::QCustom3DItem
    {
%TypeHeaderCode
#include <qcustom3dvolume.h>
%End

    public:
        explicit QCustom3DVolume(QObject *parent /TransferThis/ = 0);
        QCustom3DVolume(const QVector3D &position, const QVector3D &scaling, const QQuaternion &rotation, int textureWidth, int textureHeight, int textureDepth, QVector<unsigned char> *textureData /Transfer/, QImage::Format textureFormat, const QVector<unsigned int> &colorTable, QObject *parent /TransferThis/ = 0);
        virtual ~QCustom3DVolume();
        void setTextureWidth(int value);
        int textureWidth() const;
        void setTextureHeight(int value);
        int textureHeight() const;
        void setTextureDepth(int value);
        int textureDepth() const;
        void setTextureDimensions(int width, int height, int depth);
        int textureDataWidth() const;
        void setSliceIndexX(int value);
        int sliceIndexX() const;
        void setSliceIndexY(int value);
        int sliceIndexY() const;
        void setSliceIndexZ(int value);
        int sliceIndexZ() const;
        void setSliceIndices(int x, int y, int z);
        void setColorTable(const QVector<unsigned int> &colors);
        QVector<unsigned int> colorTable() const;
        void setTextureData(QVector<unsigned char> *data /Transfer/);
        QVector<unsigned char> *createTextureData(const QVector<QImage *> &images);
        QVector<unsigned char> *textureData() const;
        void setSubTextureData(Qt::Axis axis, int index, const void *data);
%MethodCode
            sipCpp->setSubTextureData(a0, a1, reinterpret_cast<const uchar *>(a2));
%End

        void setSubTextureData(Qt::Axis axis, int index, const QImage &image);
        void setTextureFormat(QImage::Format format);
        QImage::Format textureFormat() const;
        void setAlphaMultiplier(float mult);
        float alphaMultiplier() const;
        void setPreserveOpacity(bool enable);
        bool preserveOpacity() const;
        void setUseHighDefShader(bool enable);
        bool useHighDefShader() const;
        void setDrawSlices(bool enable);
        bool drawSlices() const;
        void setDrawSliceFrames(bool enable);
        bool drawSliceFrames() const;
        void setSliceFrameColor(const QColor &color);
        QColor sliceFrameColor() const;
        void setSliceFrameWidths(const QVector3D &values);
        QVector3D sliceFrameWidths() const;
        void setSliceFrameGaps(const QVector3D &values);
        QVector3D sliceFrameGaps() const;
        void setSliceFrameThicknesses(const QVector3D &values);
        QVector3D sliceFrameThicknesses() const;
        QImage renderSlice(Qt::Axis axis, int index);

    signals:
        void textureWidthChanged(int value);
        void textureHeightChanged(int value);
        void textureDepthChanged(int value);
        void sliceIndexXChanged(int value);
        void sliceIndexYChanged(int value);
        void sliceIndexZChanged(int value);
        void colorTableChanged();
        void textureDataChanged(QVector<uchar> *data);
        void textureFormatChanged(QImage::Format format);
        void alphaMultiplierChanged(float mult);
        void preserveOpacityChanged(bool enabled);
        void useHighDefShaderChanged(bool enabled);
        void drawSlicesChanged(bool enabled);
        void drawSliceFramesChanged(bool enabled);
        void sliceFrameColorChanged(const QColor &color);
        void sliceFrameWidthsChanged(const QVector3D &values);
        void sliceFrameGapsChanged(const QVector3D &values);
        void sliceFrameThicknessesChanged(const QVector3D &values);
    };
};

%End
