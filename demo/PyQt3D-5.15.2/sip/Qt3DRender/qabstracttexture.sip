// qabstracttexture.sip generated by MetaSIP
//
// This file is part of the Qt3DRender Python extension module.
//
// Copyright (c) 2020 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt3D.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


namespace Qt3DRender
{
%TypeHeaderCode
#include <qabstracttexture.h>
%End

    typedef QSharedPointer<Qt3DRender::QTextureGenerator> QTextureGeneratorPtr;

    class QAbstractTexture : Qt3DCore::QNode
    {
%TypeHeaderCode
#include <qabstracttexture.h>
%End

    public:
        enum Status
        {
            None /PyName=None_/,
            Loading,
            Ready,
            Error,
        };

        enum Target
        {
            TargetAutomatic,
            Target1D,
            Target1DArray,
            Target2D,
            Target2DArray,
            Target3D,
            TargetCubeMap,
            TargetCubeMapArray,
            Target2DMultisample,
            Target2DMultisampleArray,
            TargetRectangle,
            TargetBuffer,
        };

        enum TextureFormat
        {
            NoFormat,
            Automatic,
            R8_UNorm,
            RG8_UNorm,
            RGB8_UNorm,
            RGBA8_UNorm,
            R16_UNorm,
            RG16_UNorm,
            RGB16_UNorm,
            RGBA16_UNorm,
            R8_SNorm,
            RG8_SNorm,
            RGB8_SNorm,
            RGBA8_SNorm,
            R16_SNorm,
            RG16_SNorm,
            RGB16_SNorm,
            RGBA16_SNorm,
            R8U,
            RG8U,
            RGB8U,
            RGBA8U,
            R16U,
            RG16U,
            RGB16U,
            RGBA16U,
            R32U,
            RG32U,
            RGB32U,
            RGBA32U,
            R8I,
            RG8I,
            RGB8I,
            RGBA8I,
            R16I,
            RG16I,
            RGB16I,
            RGBA16I,
            R32I,
            RG32I,
            RGB32I,
            RGBA32I,
            R16F,
            RG16F,
            RGB16F,
            RGBA16F,
            R32F,
            RG32F,
            RGB32F,
            RGBA32F,
            RGB9E5,
            RG11B10F,
            RG3B2,
            R5G6B5,
            RGB5A1,
            RGBA4,
            RGB10A2,
            D16,
            D24,
            D24S8,
            D32,
            D32F,
            D32FS8X24,
            RGB_DXT1,
            RGBA_DXT1,
            RGBA_DXT3,
            RGBA_DXT5,
            R_ATI1N_UNorm,
            R_ATI1N_SNorm,
            RG_ATI2N_UNorm,
            RG_ATI2N_SNorm,
            RGB_BP_UNSIGNED_FLOAT,
            RGB_BP_SIGNED_FLOAT,
            RGB_BP_UNorm,
            R11_EAC_UNorm,
            R11_EAC_SNorm,
            RG11_EAC_UNorm,
            RG11_EAC_SNorm,
            RGB8_ETC2,
            SRGB8_ETC2,
            RGB8_PunchThrough_Alpha1_ETC2,
            SRGB8_PunchThrough_Alpha1_ETC2,
            RGBA8_ETC2_EAC,
            SRGB8_Alpha8_ETC2_EAC,
            RGB8_ETC1,
            SRGB8,
            SRGB8_Alpha8,
            SRGB_DXT1,
            SRGB_Alpha_DXT1,
            SRGB_Alpha_DXT3,
            SRGB_Alpha_DXT5,
            SRGB_BP_UNorm,
            DepthFormat,
            AlphaFormat,
            RGBFormat,
            RGBAFormat,
            LuminanceFormat,
            LuminanceAlphaFormat,
%If (Qt3D_5_14_0 -)
            RGB10A2U,
%End
        };

        enum Filter
        {
            Nearest,
            Linear,
            NearestMipMapNearest,
            NearestMipMapLinear,
            LinearMipMapNearest,
            LinearMipMapLinear,
        };

        enum CubeMapFace
        {
            CubeMapPositiveX,
            CubeMapNegativeX,
            CubeMapPositiveY,
            CubeMapNegativeY,
            CubeMapPositiveZ,
            CubeMapNegativeZ,
%If (Qt3D_5_8_0 -)
            AllFaces,
%End
        };

        enum ComparisonFunction
        {
            CompareLessEqual,
            CompareGreaterEqual,
            CompareLess,
            CompareGreater,
            CompareEqual,
            CommpareNotEqual,
            CompareAlways,
            CompareNever,
        };

        enum ComparisonMode
        {
            CompareRefToTexture,
            CompareNone,
        };

        virtual ~QAbstractTexture();
        Qt3DRender::QAbstractTexture::Target target() const;
        Qt3DRender::QAbstractTexture::TextureFormat format() const;
        bool generateMipMaps() const;
        Qt3DRender::QAbstractTexture::Status status() const;
        void addTextureImage(Qt3DRender::QAbstractTextureImage *textureImage /GetWrapper/);
%MethodCode
            // This takes ownership only if it doesn't already have a parent.
            if (!a0->parent())
                sipTransferTo(a0Wrapper, sipSelf);
            
            sipCpp->addTextureImage(a0);
%End

        void removeTextureImage(Qt3DRender::QAbstractTextureImage *textureImage);
        QVector<Qt3DRender::QAbstractTextureImage *> textureImages() const;
        void setWrapMode(const Qt3DRender::QTextureWrapMode &wrapMode);
        Qt3DRender::QTextureWrapMode *wrapMode();
        void setSize(int width, int height = 1, int depth = 1);
        Qt3DRender::QAbstractTexture::Filter minificationFilter() const;
        Qt3DRender::QAbstractTexture::Filter magnificationFilter() const;
        float maximumAnisotropy() const;
        Qt3DRender::QAbstractTexture::ComparisonFunction comparisonFunction() const;
        Qt3DRender::QAbstractTexture::ComparisonMode comparisonMode() const;
        int width() const;
        int height() const;
        int depth() const;
        int layers() const;
%If (Qt3D_5_8_0 -)
        int samples() const;
%End
        Qt3DRender::QTextureGeneratorPtr dataGenerator() const;

    public slots:
        void setFormat(Qt3DRender::QAbstractTexture::TextureFormat format);
        void setGenerateMipMaps(bool gen);
        void setWidth(int width);
        void setHeight(int height);
        void setDepth(int depth);
        void setMinificationFilter(Qt3DRender::QAbstractTexture::Filter f);
        void setMagnificationFilter(Qt3DRender::QAbstractTexture::Filter f);
        void setMaximumAnisotropy(float anisotropy);
        void setComparisonFunction(Qt3DRender::QAbstractTexture::ComparisonFunction function);
        void setComparisonMode(Qt3DRender::QAbstractTexture::ComparisonMode mode);
        void setLayers(int layers);
%If (Qt3D_5_8_0 -)
        void setSamples(int samples);
%End

    signals:
        void formatChanged(Qt3DRender::QAbstractTexture::TextureFormat format /ScopesStripped=2/);
        void statusChanged(Qt3DRender::QAbstractTexture::Status status /ScopesStripped=2/);
        void generateMipMapsChanged(bool generateMipMaps);
        void widthChanged(int width);
        void heightChanged(int height);
        void depthChanged(int depth);
        void magnificationFilterChanged(Qt3DRender::QAbstractTexture::Filter magnificationFilter /ScopesStripped=2/);
        void minificationFilterChanged(Qt3DRender::QAbstractTexture::Filter minificationFilter /ScopesStripped=2/);
        void maximumAnisotropyChanged(float maximumAnisotropy);
        void comparisonFunctionChanged(Qt3DRender::QAbstractTexture::ComparisonFunction comparisonFunction /ScopesStripped=2/);
        void comparisonModeChanged(Qt3DRender::QAbstractTexture::ComparisonMode comparisonMode /ScopesStripped=2/);
        void layersChanged(int layers);
%If (Qt3D_5_8_0 -)
        void samplesChanged(int samples);
%End

    protected:
        explicit QAbstractTexture(Qt3DCore::QNode *parent /TransferThis/ = 0);
        QAbstractTexture(Qt3DRender::QAbstractTexture::Target target, Qt3DCore::QNode *parent /TransferThis/ = 0);
        void setStatus(Qt3DRender::QAbstractTexture::Status status);
%If (Qt3D_5_10_0 -)
        virtual void sceneChangeEvent(const Qt3DCore::QSceneChangePtr &change);
%End

    public:
%If (Qt3D_5_13_0 -)

        enum HandleType
        {
            NoHandle,
            OpenGLTextureId,
        };

%End
%If (Qt3D_5_13_0 -)
        Qt3DRender::QAbstractTexture::HandleType handleType() const;
%End
%If (Qt3D_5_13_0 -)
        QVariant handle() const;
%End

    signals:
%If (Qt3D_5_13_0 -)
        void handleTypeChanged(Qt3DRender::QAbstractTexture::HandleType handleType);
%End
%If (Qt3D_5_13_0 -)
        void handleChanged(QVariant handle);
%End

    public:
%If (Qt3D_5_14_0 -)
        void updateData(const Qt3DRender::QTextureDataUpdate &update);
%End
    };
};
